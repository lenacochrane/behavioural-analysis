import sys
import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pyarrow.feather as feather
import cv2
import re
from scipy.spatial.distance import pdist
from shapely import wkt
import glob
from random import sample
from matplotlib.patches import Ellipse
from sklearn.decomposition import PCA
import imageio.v2 as imageio
from scipy.stats import linregress
import matplotlib as mpl
from scipy.stats import binomtest
from statsmodels.stats.multitest import multipletests
import ast
import matplotlib.gridspec as gridspec
from matplotlib.colors import Normalize
from matplotlib.lines import Line2D
from matplotlib.colors import LinearSegmentedColormap

#### CLASS TO ANALYSE THE CLUSTERS  
class ClusterPipeline:

    def __init__(self, directory, interactions, clusters, cluster_name, video_path):
        
        self.directory = directory
        self.interaction_path = interactions 
        self.cluster_path = clusters
        self.cluster_name = cluster_name
        self.video_path = video_path

        self.interactions = None
        self.clusters = None
        self.df = None
        
    
    #### METHOD LOADING_DATA: LOAD AND MERGE DATAFRAMES
    def loading_data(self):

        ## LOAD DATAFRAMES

        self.interactions = pd.read_csv(self.interaction_path)
        self.clusters = pd.read_csv(self.cluster_path)

        ## MISSING INTERACTIONS BETWEEN DATAFRAMES

        set1 = set(self.interactions['interaction_id'].unique())
        set2 = set(self.clusters['interaction_id'].unique())
        missing_from_cluster = sorted(set1 - set2)
        missing_from_cropped  = sorted(set2 - set1)
        print(f">>> {len(missing_from_cluster)} IDs in cropped not in cluster (e.g. {missing_from_cluster[:5]})")
        print(f">>> {len(missing_from_cropped)} IDs in cluster not in cropped (e.g. {missing_from_cropped[:5]})")

        ## MERGE DATAFRAMES

        self.df = pd.merge(
            self.interactions, 
            self.clusters[['interaction_id', self.cluster_name]], 
            on='interaction_id', 
            how='inner'
        )
    

    #### METHOD ANCHOR_PARTNER: CREATE ANCHOR AND PARTNER BASED ON LINEARITY OF TRACK  
    def anchor_partner(self):
        
        df = self.df

        ## CREATE ALIGNED AND PARTNER TRACKS FOR DRAWING TRAJECTORIES 

        ## Returns a straightness score 
        def compute_pca_axis(points):
            pca = PCA(n_components=2).fit(points)
            axis = pca.components_[0]
            score = pca.explained_variance_ratio_[0]
            # ensure the axis points upward
            return (axis if axis[1] >= 0 else -axis), score
        
        ## == Align the tracks (anchor 0,0) and rotate partner accordingly (on the right)
        def align_and_flip(track, anchor_axis, anchor_start):
            X = track - anchor_start
            phi = np.arctan2(anchor_axis[1], anchor_axis[0])  # angle of axis
            alpha = np.pi/2 - phi                            # rotate to +y
            R = np.array([[np.cos(alpha), -np.sin(alpha)],
                        [np.sin(alpha),  np.cos(alpha)]])
            X_rot = X.dot(R.T)
            return X_rot
        
        df['anchor x_body'] = np.nan
        df['anchor y_body'] = np.nan
        df['partner x_body'] = np.nan
        df['partner y_body'] = np.nan

        ## == Generate the anchor and partner x,y coordinates for future

        for interaction_id, group in df.groupby('interaction_id'):
            group = group.sort_values('Frame')
            coords1 = group[['Track_1 x_body','Track_1 y_body']].values
            coords2 = group[['Track_2 x_body','Track_2 y_body']].values
            if len(coords1) < 2 or len(coords2) < 2:
                continue
            # Compute PCA axes & scores
            axis1, s1 = compute_pca_axis(coords1)
            axis2, s2 = compute_pca_axis(coords2)
            # Choose anchor and partner
            if s1 >= s2:
                winner = 1
                anchor_pts, partner_pts, anchor_axis = coords1, coords2, axis1
            else:
                winner = 2
                anchor_pts, partner_pts, anchor_axis = coords2, coords1, axis2

            # Align both
            start = anchor_pts[0]
            A_al = align_and_flip(anchor_pts, anchor_axis, start)
            B_al = align_and_flip(partner_pts, anchor_axis, start)

            # --- NEW: align head/tail using the SAME reference (before flips) ---
            h1 = group[['Track_1 x_head','Track_1 y_head']].dropna().values
            t1 = group[['Track_1 x_tail','Track_1 y_tail']].dropna().values
            h2 = group[['Track_2 x_head','Track_2 y_head']].dropna().values
            t2 = group[['Track_2 x_tail','Track_2 y_tail']].dropna().values

            A_head = align_and_flip(h1 if winner == 1 else h2, anchor_axis, start) if (len(h1) or len(h2)) else np.empty((0,2))
            A_tail = align_and_flip(t1 if winner == 1 else t2, anchor_axis, start) if (len(t1) or len(t2)) else np.empty((0,2))
            B_head = align_and_flip(h2 if winner == 1 else h1, anchor_axis, start) if (len(h1) or len(h2)) else np.empty((0,2))
            B_tail = align_and_flip(t2 if winner == 1 else t1, anchor_axis, start) if (len(t1) or len(t2)) else np.empty((0,2))
        # --------------------------------------------------------------------

            # Horizontal flip if partner is left
            # if np.median(B_al[:,0]) < 0:
            #     A_al[:,0] *= -1
            #     B_al[:,0] *= -1

            # Horizontal flip if partner starts on the left
            if B_al[0, 0] < 0:
                A_al[:, 0] *= -1
                B_al[:, 0] *= -1
                # --- NEW: apply same horizontal flip to head/tail
                if A_head.size: A_head[:, 0] *= -1
                if A_tail.size: A_tail[:, 0] *= -1
                if B_head.size: B_head[:, 0] *= -1
                if B_tail.size: B_tail[:, 0] *= -1

            # Vertical flip if anchor is predominantly down
            if np.mean(A_al[:,1]) < 0:
                A_al[:,1] *= -1
                B_al[:,1] *= -1
                    # --- NEW: apply same vertical flip to head/tail
                if A_head.size: A_head[:, 1] *= -1
                if A_tail.size: A_tail[:, 1] *= -1
                if B_head.size: B_head[:, 1] *= -1
                if B_tail.size: B_tail[:, 1] *= -1


            # Assign back to DataFrame
            idx = group.index[:len(A_al)]
            df.loc[idx, ['anchor x_body','anchor y_body']]  = A_al
            df.loc[idx, ['partner x_body','partner y_body']] = B_al# Initialize aligned columns

            # --- NEW: write aligned head/tail back (each uses its own length) ---
            if A_head.size:
                df.loc[group.index[:len(A_head)], ['anchor x_head','anchor y_head']] = A_head
            if A_tail.size:
                df.loc[group.index[:len(A_tail)], ['anchor x_tail','anchor y_tail']] = A_tail
            if B_head.size:
                df.loc[group.index[:len(B_head)], ['partner x_head','partner y_head']] = B_head
            if B_tail.size:
                df.loc[group.index[:len(B_tail)], ['partner x_tail','partner y_tail']] = B_tail
            # --------------------------------------------------------------------

            # → tag which original track was anchor (1 or 2)
            df.loc[idx, 'anchor_track']  = winner
            df.loc[idx, 'partner_track'] = 3 - winner


        # === HEADING ANGLE CHANGE ===
        df['track1_heading_angle_change'] = df.groupby("interaction_id")["track1_angle"].diff().abs()
        df['track2_heading_angle_change'] = df.groupby("interaction_id")["track2_angle"].diff().abs()

        # === APPROACH ANGLE CHANGE ===
        df['track1_approach_angle_change'] = df.groupby("interaction_id")["track1_approach_angle"].diff().abs()
        df['track2_approach_angle_change'] = df.groupby("interaction_id")["track2_approach_angle"].diff().abs()

        metrics = [
        'speed',
        'acceleration',
        'angle',
        'approach_angle']

        for m in metrics:
            t1 = df[f'track1_{m}']
            t2 = df[f'track2_{m}']
            df[f'anchor_{m}']  = np.where(df['anchor_track']==1, t1, t2)
            df[f'partner_{m}'] = np.where(df['anchor_track']==1, t2, t1)

            # === Assign anchor/partner versions
            df['anchor_heading_angle_change']  = np.where(df['anchor_track'] == 1, df['track1_heading_angle_change'], df['track2_heading_angle_change'])
            df['partner_heading_angle_change'] = np.where(df['anchor_track'] == 1, df['track2_heading_angle_change'], df['track1_heading_angle_change'])

            df['anchor_approach_angle_change']  = np.where(df['anchor_track'] == 1, df['track1_approach_angle_change'], df['track2_approach_angle_change'])
            df['partner_approach_angle_change'] = np.where(df['anchor_track'] == 1, df['track2_approach_angle_change'], df['track1_approach_angle_change'])

        
        self.df = df


    #### METHOD SANITY_CHECK_ANCHOR_PARTNER: SANITY CHECK WHEREBY ANCHOR AND PARTNER REVERSED TO LINEARITY SCORE
    def sanity_check_anchor_partner(self):
        
        df = self.df

        ## CREATE ALIGNED AND PARTNER TRACKS FOR DRAWING TRAJECTORIES 

        ## Returns a straightness score 
        def compute_pca_axis(points):
            pca = PCA(n_components=2).fit(points)
            axis = pca.components_[0]
            score = pca.explained_variance_ratio_[0]
            # ensure the axis points upward
            return (axis if axis[1] >= 0 else -axis), score
        
        ## == Align the tracks (anchor 0,0) and rotate partner accordingly (on the right)
        def align_and_flip(track, anchor_axis, anchor_start):
            X = track - anchor_start
            phi = np.arctan2(anchor_axis[1], anchor_axis[0])  # angle of axis
            alpha = np.pi/2 - phi                            # rotate to +y
            R = np.array([[np.cos(alpha), -np.sin(alpha)],
                        [np.sin(alpha),  np.cos(alpha)]])
            X_rot = X.dot(R.T)
            return X_rot
        
        df['anchor x_body'] = np.nan
        df['anchor y_body'] = np.nan
        df['partner x_body'] = np.nan
        df['partner y_body'] = np.nan

        ## == Generate the anchor and partner x,y coordinates for future

        for interaction_id, group in df.groupby('interaction_id'):
            group = group.sort_values('Frame')
            coords1 = group[['Track_1 x_body','Track_1 y_body']].values
            coords2 = group[['Track_2 x_body','Track_2 y_body']].values
            if len(coords1) < 2 or len(coords2) < 2:
                continue
            # Compute PCA axes & scores
            axis1, s1 = compute_pca_axis(coords1)
            axis2, s2 = compute_pca_axis(coords2)


            # Choose anchor and partner
            if s1 >= s2:
                winner = 2
                anchor_pts, partner_pts, anchor_axis = coords2, coords1, axis2
            else:
                winner = 1
                anchor_pts, partner_pts, anchor_axis = coords1, coords2, axis1

            # Align both
            start = anchor_pts[0]
            A_al = align_and_flip(anchor_pts, anchor_axis, start)
            B_al = align_and_flip(partner_pts, anchor_axis, start)

            # --- NEW: align head/tail using the SAME reference (before flips) ---
            h1 = group[['Track_1 x_head','Track_1 y_head']].dropna().values
            t1 = group[['Track_1 x_tail','Track_1 y_tail']].dropna().values
            h2 = group[['Track_2 x_head','Track_2 y_head']].dropna().values
            t2 = group[['Track_2 x_tail','Track_2 y_tail']].dropna().values

            A_head = align_and_flip(h1 if winner == 1 else h2, anchor_axis, start) if (len(h1) or len(h2)) else np.empty((0,2))
            A_tail = align_and_flip(t1 if winner == 1 else t2, anchor_axis, start) if (len(t1) or len(t2)) else np.empty((0,2))
            B_head = align_and_flip(h2 if winner == 1 else h1, anchor_axis, start) if (len(h1) or len(h2)) else np.empty((0,2))
            B_tail = align_and_flip(t2 if winner == 1 else t1, anchor_axis, start) if (len(t1) or len(t2)) else np.empty((0,2))
        # --------------------------------------------------------------------


            # Horizontal flip if partner starts on the left
            if B_al[0, 0] < 0:
                A_al[:, 0] *= -1
                B_al[:, 0] *= -1
                # --- NEW: apply same horizontal flip to head/tail
                if A_head.size: A_head[:, 0] *= -1
                if A_tail.size: A_tail[:, 0] *= -1
                if B_head.size: B_head[:, 0] *= -1
                if B_tail.size: B_tail[:, 0] *= -1

            # Vertical flip if anchor is predominantly down
            if np.mean(A_al[:,1]) < 0:
                A_al[:,1] *= -1
                B_al[:,1] *= -1
                    # --- NEW: apply same vertical flip to head/tail
                if A_head.size: A_head[:, 1] *= -1
                if A_tail.size: A_tail[:, 1] *= -1
                if B_head.size: B_head[:, 1] *= -1
                if B_tail.size: B_tail[:, 1] *= -1

            # Assign back to DataFrame
            idx = group.index[:len(A_al)]
            df.loc[idx, ['anchor x_body','anchor y_body']]  = A_al
            df.loc[idx, ['partner x_body','partner y_body']] = B_al# Initialize aligned columns

            # --- NEW: write aligned head/tail back (each uses its own length) ---
            if A_head.size:
                df.loc[group.index[:len(A_head)], ['anchor x_head','anchor y_head']] = A_head
            if A_tail.size:
                df.loc[group.index[:len(A_tail)], ['anchor x_tail','anchor y_tail']] = A_tail
            if B_head.size:
                df.loc[group.index[:len(B_head)], ['partner x_head','partner y_head']] = B_head
            if B_tail.size:
                df.loc[group.index[:len(B_tail)], ['partner x_tail','partner y_tail']] = B_tail
            # --------------------------------------------------------------------

            # → tag which original track was anchor (1 or 2)
            df.loc[idx, 'anchor_track']  = winner
            df.loc[idx, 'partner_track'] = 3 - winner


        # === HEADING ANGLE CHANGE ===
        df['track1_heading_angle_change'] = df.groupby("interaction_id")["track1_angle"].diff().abs()
        df['track2_heading_angle_change'] = df.groupby("interaction_id")["track2_angle"].diff().abs()

        # === APPROACH ANGLE CHANGE ===
        df['track1_approach_angle_change'] = df.groupby("interaction_id")["track1_approach_angle"].diff().abs()
        df['track2_approach_angle_change'] = df.groupby("interaction_id")["track2_approach_angle"].diff().abs()

        metrics = [
        'speed',
        'acceleration',
        'angle',
        'approach_angle']

        for m in metrics:
            t1 = df[f'track1_{m}']
            t2 = df[f'track2_{m}']
            df[f'anchor_{m}']  = np.where(df['anchor_track']==1, t1, t2)
            df[f'partner_{m}'] = np.where(df['anchor_track']==1, t2, t1)

            # === Assign anchor/partner versions
            df['anchor_heading_angle_change']  = np.where(df['anchor_track'] == 1, df['track1_heading_angle_change'], df['track2_heading_angle_change'])
            df['partner_heading_angle_change'] = np.where(df['anchor_track'] == 1, df['track2_heading_angle_change'], df['track1_heading_angle_change'])

            df['anchor_approach_angle_change']  = np.where(df['anchor_track'] == 1, df['track1_approach_angle_change'], df['track2_approach_angle_change'])
            df['partner_approach_angle_change'] = np.where(df['anchor_track'] == 1, df['track2_approach_angle_change'], df['track1_approach_angle_change'])

        
        self.df = df
    

    def hierarchal_mean_trace_summary(self):
        
        df = self.df.copy()
        cluster_name = self.cluster_name
       
        hierarchal_tree = (( ((1,2), (3,4)), (5, (6,7)) ),( ((8,9), (10,11)), 12 ))

        ## LEVEL 0
        x1, y1 = 1, 0
        x2, y2 = 2, 0
        x3, y3 = 3, 0
        x4, y4 = 4, 0
        x5, y5 = 5, 0
        x6, y6 = 6, 0
        x7, y7 = 7, 0
        x8, y8 = 8, 0
        x9, y9 = 9, 0
        x10, y10 = 10, 0
        x11, y11 = 11, 0
        x12, y12 = 12, 0

        ## LEVEL 1
        x_12, y_12 = (x1 + x2) / 2, 1 # (midpoint of x1, x2) and (y=1) is coordinates 
        x34, y34 = (x3 + x4) / 2, 1
        x67, y67 = (x6 + x7) / 2, 1
        x89, y89 = (x8 + x9) / 2, 1
        x1011, y1011 = (x10 + x11) / 2, 1

        ## LEVEL 2
        x1234, y1234 = (x_12 + x34) / 2, 2
        x567, y567 = (x5 + x67) / 2, 2
        x891011, y891011 = (x89 + x1011) / 2, 2

        ## LEVEL 3
        x1234567, y1234567 = (x1234 + x567) / 2, 3
        x89101112, y89101112 = (x891011 + x12) / 2, 3   

        ## LEVEL 4
        x_123456789101112, y_123456789101112 = (x1234567 + x89101112) / 2, 4

        mpl.rcParams['pdf.fonttype'] = 42   # use TrueType fonts, not Type 3 (outlines)
        mpl.rcParams['ps.fonttype']  = 42
        mpl.rcParams['font.family']  = 'Arial'



        fig = plt.figure(figsize=(15, 4))
        gs = gridspec.GridSpec(3, 1, height_ratios=[0.3, 0.6, 0.05], hspace=0.3)

        ax1 = fig.add_subplot(gs[0])  # top: hierarchal tree
        # ax2 = fig.add_subplot(gs[1])
        sub_ax2 = gs[1].subgridspec(1, 12, wspace=0.1)
        axes_ax2 = [fig.add_subplot(sub_ax2[0, i]) for i in range(12)]

        #ax3 = fig.add_subplot(gs[2])  # bottom: average contact frames
        sub_ax3 = gs[2].subgridspec(1, 12, wspace=0.1)
        ax3 = fig.add_subplot(sub_ax3[0, :])  # one long axis spanning all 12 columns

        ## PLOTTING HIERARCHAL TREE - MANUALLY USING COORDINATES ABOVE 
        # ax.plot([x_start, x_end], [y_start, y_end])

        ax1.plot([x1, x1], [y1, y_12], color='black') #12
        ax1.plot([x2, x2], [y2, y_12], color='black') #12
        ax1.plot([x1, x2], [y_12, y_12], color='black') #12

        ax1.plot([x3, x3], [y3, y34], color='black') #34
        ax1.plot([x4, x4], [y4, y34], color='black') #34
        ax1.plot([x3, x4], [y34, y34], color='black') #34

        ax1.plot([x_12, x_12], [y_12, y1234], color='black') #1234
        ax1.plot([x34, x34], [y34, y1234], color='black') #1234
        ax1.plot([x_12, x34], [y1234, y1234], color='black') #1234

        ax1.plot([x6, x6], [y6, y67], color='black') #67
        ax1.plot([x7, x7], [y7, y67], color='black') #67
        ax1.plot([x6, x7], [y67, y67], color='black') #67

        ax1.plot([x67, x67], [y67, y567], color='black') #567
        ax1.plot([x5, x5], [y5, y567], color='black') #567
        ax1.plot([x5, x67], [y567, y567], color='black') #567

        ax1.plot([x8, x8], [y8, y89], color='black') #89
        ax1.plot([x9, x9], [y9, y89], color='black') #89
        ax1.plot([x8, x9], [y89, y89], color='black') #89

        ax1.plot([x10, x10], [y10, y1011], color='black') #1011
        ax1.plot([x11, x11], [y11, y1011], color='black') #1011
        ax1.plot([x10, x11], [y1011, y1011], color='black') #1011

        ax1.plot([x89, x89], [y89, y891011], color='black') #891011
        ax1.plot([x1011, x1011], [y1011, y891011], color='black') #891011
        ax1.plot([x89, x1011], [y891011, y891011], color='black') #891011

        ax1.plot([x1234, x1234], [y1234, y1234567], color='black') #1234567
        ax1.plot([x567, x567], [y567, y1234567], color='black') #1234567
        ax1.plot([x1234, x567], [y1234567, y1234567], color='black') #1234567

        ax1.plot([x12, x12], [y12, y89101112], color='black') #89101112
        ax1.plot([x891011, x891011], [y891011, y89101112], color='black') #89101112
        ax1.plot([x12, x891011], [y89101112, y89101112], color='black') #89101112

        ax1.plot([x1234567, x1234567], [y1234567, y_123456789101112], color='black') #123456789101112
        ax1.plot([x89101112, x89101112], [y89101112, y_123456789101112], color='black') #123456789101112
        ax1.plot([x1234567, x89101112], [y_123456789101112, y_123456789101112], color='black') #123456789101112

        for spine in ax1.spines.values():
            spine.set_visible(False)
        ax1.set_xticks([])
        ax1.set_yticks([])
        
        ## MEAN TRACES PLOTTING

        anchor_base = "#D23411"   
        partner_base = "#1734C5"
        anchor_cmap = plt.cm.Reds
        partner_cmap = plt.cm.Blues

        ordered_frames = sorted(df["Normalized Frame"].dropna().unique())
        norm_frames = Normalize(vmin=ordered_frames[0], vmax=ordered_frames[-1]) #ltr for colour mapping

        clusters = sorted(df[cluster_name].unique())

        for cluster, ax in zip(clusters, axes_ax2):
            cluster_df = df[df[cluster_name] == cluster].copy()
            by_frame = cluster_df.sort_values("Normalized Frame").groupby("Normalized Frame")
            frames = [f for f in by_frame.groups.keys() if f == f] # list of frames (non-nan)
            
            # role+node, return mean X series and mean Y series (indexed by frame)
            def get_means(role, node):
                mx = by_frame[f"{role} x_{node}"].mean()  # Series: index = frame → mean x
                my = by_frame[f"{role} y_{node}"].mean()  # Series: index = frame → mean y
                return mx, my

            ## DRAW TRAILS
            for node in ("head", "body", "tail"):
                anchor_x, anchor_y = get_means("anchor",  node) # xy means per frame for anchor
                partner_x, partner_y = get_means("partner", node) # xy means per frame for partner

                for f0, f1 in zip(frames[:-1], frames[1:]): # consecutive frame pairs (frame 0, frame 1), (frame 1, frame 2), ...
                    # anchor
                    if f0 in anchor_x.index and f1 in anchor_x.index: # check that both frames have data
                        x0, y0 = anchor_x.loc[f0], anchor_y.loc[f0]
                        x1, y1 = anchor_x.loc[f1], anchor_y.loc[f1]
                        if np.isfinite(x0) and np.isfinite(y0) and np.isfinite(x1) and np.isfinite(y1):
                            ax.plot([x0, x1], [y0, y1],
                                    color=anchor_cmap(norm_frames(f1)), alpha=0.7, linewidth=1.2, zorder=1)
                    # partner
                    if f0 in partner_x.index and f1 in partner_x.index:
                        x0, y0 = partner_x.loc[f0], partner_y.loc[f0]
                        x1, y1 = partner_x.loc[f1], partner_y.loc[f1]
                        if np.isfinite(x0) and np.isfinite(y0) and np.isfinite(x1) and np.isfinite(y1):
                            ax.plot([x0, x1], [y0, y1],
                                    color=partner_cmap(norm_frames(f1)), alpha=0.7, linewidth=1.2, zorder=1) #zorder=1 trails goes underneath skeletons and markers
        
            ## DRAW SKELETONS: CONNECT HEAD→BODY→TAIL PER FRAME (TIME-COLORED)
            for f in frames:
                # anchor
                parts = {}
                for node in ("head", "body", "tail"):
                    x_means = by_frame[f"anchor x_{node}"].mean() 
                    y_means = by_frame[f"anchor y_{node}"].mean()

                    if f in x_means.index:
                        x, y = x_means.loc[f], y_means.loc[f]
                        if np.isfinite(x) and np.isfinite(y):
                            parts[node] = (x, y)
                
                if len(parts) == 3:
                 ax.plot([parts["head"][0], parts["body"][0], parts["tail"][0]],
                            [parts["head"][1], parts["body"][1], parts["tail"][1]],
                            color=anchor_cmap(norm_frames(f)), alpha=0.75, linewidth=1.0, zorder=2)
                # partner
                parts = {}
                for node in ("head", "body", "tail"):
                    x_means = by_frame[f"partner x_{node}"].mean()
                    y_means = by_frame[f"partner y_{node}"].mean()
                    if f in x_means.index:
                        x, y = x_means.loc[f], y_means.loc[f]
                        if np.isfinite(x) and np.isfinite(y):
                            parts[node] = (x, y)
                if len(parts) == 3:
                    ax.plot([parts["head"][0], parts["body"][0], parts["tail"][0]],
                            [parts["head"][1], parts["body"][1], parts["tail"][1]],
                            color=partner_cmap(norm_frames(f)), alpha=0.75, linewidth=1.0, zorder=2)


            ## POINTS FOR NODES AT EACH FRAME (TIME COLORED; HEAD BIGGER)
            node_marker = {"head": "o", "body": "o", "tail": "o"}
            size_map  = {"head": 6, "body": 4, "tail": 2}

            for node in ("head", "body", "tail"):
                anchor_x_means, anchor_y_means = get_means("anchor",  node)
                partner_x_means, partner_y_means = get_means("partner", node)
                for f in frames:
                    if f in anchor_x_means.index:
                        x, y = anchor_x_means.loc[f], anchor_y_means.loc[f]
                        if np.isfinite(x) and np.isfinite(y):
                            ax.scatter(x, y, s=size_map[node], marker=node_marker[node],
                                        color=anchor_cmap(norm_frames(f)), alpha=0.9, zorder=3)
                    
                    if f in partner_x_means.index:
                        x, y = partner_x_means.loc[f], partner_y_means.loc[f]
                        if np.isfinite(x) and np.isfinite(y):
                            ax.scatter(x, y, s=size_map[node], marker=node_marker[node],
                                        color=partner_cmap(norm_frames(f)), alpha=0.9, zorder=3)

            # 6) tidy the one big axis
            xlim = (-50, 100)
            ylim = (-10, 300)
            ax.set_xlim(*xlim)
            ax.set_ylim(*ylim)
            # ax.set_aspect("equal", adjustable="box")
            ax.set_title(cluster, fontsize=16, fontweight='bold')
            for ax in axes_ax2:
                ax.axis('off')

        ## AVERAGE CONTACT FRAMES 

        interaction_contact_summary = []

        for cluster_id in sorted(df[cluster_name].unique()):
            cluster_df = df[df[cluster_name] == cluster_id]
            for inter_id in cluster_df["interaction_id"].unique():
                inter_df = cluster_df[cluster_df["interaction_id"] == inter_id]
                n_close = (inter_df["min_distance"] < 1).sum()
                interaction_contact_summary.append({
                    "cluster": cluster_id,
                    "interaction_id": inter_id,
                    "frames_below_1mm": n_close})

        df_interaction_contact = pd.DataFrame(interaction_contact_summary)

        mean_frames = (
            df_interaction_contact
            .groupby('cluster')['frames_below_1mm']
            .mean()
        )

        # 2) ensure index types match the deviation index (important for reindex)
        mean_frames.index = mean_frames.index.astype(int)
        order = [1,2,3,4,5,6,7,8,9,10,11,12]   # matches your dendrogram order
        mean_frames = mean_frames.reindex(order, fill_value=0)
        heat = mean_frames.to_numpy()[np.newaxis, :]


        # colors = ["skyblue", "mediumseagreen", "darkgreen"]
        # # build a sequential colormap from those
        # my_cmap = LinearSegmentedColormap.from_list("greenblue_custom", colors)

        # 5) draw the heat “box” (single row)
        im = ax3.imshow(
            heat,
            aspect='auto',
            interpolation='nearest',
            vmin=0,  # anchor scale at 0
            cmap='PuBu',
            # cmap='PuBuGn' 
        )

        ax3.set_yticklabels([])
        ax3.set_yticks([])
        ax3.tick_params(left=False)
        ax3.set_xlabel("")             # remove x-axis label
        ax3.set_xticklabels([])        # remove tick labels
        ax3.set_xticks([])             # remove ticks entirely
        ax3.tick_params(bottom=False)  # remove the small tick lines


        # optional: make the heat row compact and boxy
        for spine in ax3.spines.values():
            spine.set_visible(False)
        
        # === add colorbar OUTSIDE grid ===
        cbar = fig.colorbar(
            im,
            ax=[ax1, *axes_ax2, ax3],        # anchors to both axes (so it aligns with total figure height)
            fraction=0.01,         # width of colorbar relative to figure
            pad=0.01,              # horizontal gap between plots and colorbar
            location='right'       # move to right side
        )
        cbar.set_label('Average Contact Frames', rotation=270, labelpad=15)

        # fig.subplots_adjust(hspace=0.0)
        output = os.path.join(self.directory, "test")

        output_pdf = os.path.join(output, "hierarchal_mean_trace_summary.pdf")
        plt.savefig(output_pdf, format='pdf', bbox_inches='tight', dpi=300)

        output_png = os.path.join(output, "hierarchal_mean_trace_summary.png")
        plt.savefig(output_png, dpi=300, bbox_inches='tight')
        plt.close(fig)

    

    def barplots(self):

        df = self.clusters
        full_df = self.df
        cluster_name = self.cluster_name

        palette = {
                "group": "C0",   
                "iso": "C1"}
        

        mpl.rcParams['pdf.fonttype'] = 42
        mpl.rcParams['ps.fonttype']  = 42
        

        # Collapse to unique interactions (to avoid overweighting frames)
        inter_per_video = (
            df[['file', 'condition', 'interaction_id', cluster_name]]
            .drop_duplicates(subset=['file', 'interaction_id'])
        )

        # Count interactions per (video, condition, cluster)
        counts = (
            inter_per_video
            .groupby(['file', 'condition', cluster_name])
            .size()
            .reset_index(name='count')
        )

        # Compute total interactions per video (for normalization)
        totals = (
            counts.groupby('file')['count']
            .transform('sum')
        )

        # Add proportion column
        counts['proportion'] = counts['count'] / totals

        # Ensure all cluster IDs appear (even if missing in some videos)
        all_clusters = sorted(df[cluster_name].unique())
        
        summary_df = (
            counts
            .set_index(['file', 'condition', cluster_name])
            .unstack(fill_value=0)
            .stack()
            .reset_index()
        )
        summary_df.rename(columns={0: 'proportion'}, inplace=True)


        # Now you can plot with seaborn
        plt.figure(figsize=(8, 6))
        sns.barplot(
            data=summary_df,
            x=cluster_name, y='proportion', hue='condition',ci='sd', alpha=0.8, palette=palette,     linewidth=1.2,        # thickness of the bar edges
    edgecolor='black')
        
        plt.title("Proportion of Clusters", fontsize=16, fontweight='bold')
        plt.xlabel("Cluster ID")
        plt.ylabel("Proportion")
        # plt.xticks(rotation=90)
        plt.tight_layout()

        output = os.path.join(self.directory, "test")

        per_video_prop_path = os.path.join(output, 'cluster_proportions_per_video.png')
        plt.savefig(per_video_prop_path, dpi=300, bbox_inches='tight')
        path = os.path.join(output, 'cluster_proportions_per_video.pdf')  
        plt.savefig(path, format="pdf", bbox_inches="tight", dpi=300, transparent=True)
        plt.close()



        ### OBSERVED - EXPECTED DEVIATION PLOT



        cluster_counts = (df.groupby([cluster_name, 'condition']).size().unstack(fill_value=0).reindex(columns=['group', 'iso'], fill_value=0))  # count number per cluster per condition


        total_group = cluster_counts['group'].sum()
        total_iso   = cluster_counts['iso'].sum()
        total_all   = total_group + total_iso

        expected_group = total_group / total_all   # e.g., ~0.56

        observed_group_frac = cluster_counts['group'] / (cluster_counts['group'] + cluster_counts['iso']).replace({0: np.nan}) ## observed fraction
        observed_group_frac = observed_group_frac.fillna(0.0)

        deviation = observed_group_frac - expected_group ## expected fraction

        deviation_sorted = deviation.sort_values()
        colors = ['C1' if val < 0 else 'C0' for val in deviation_sorted.values]

        ## Binomial test per cluster
        results = []
        for cluster_id, row in cluster_counts.iterrows():
            k = row['group']
            n = row['group'] + row['iso']
            if n > 0:
                p_exp = expected_group
                res = binomtest(k, n, p_exp, alternative='two-sided')
                results.append((cluster_id, res.pvalue))
            else:
                results.append((cluster_id, np.nan))

        pvals = pd.DataFrame(results, columns=['cluster_id', 'p_value'])

        ## correct for multple test - false positives
        pvals['p_adj'] = multipletests(pvals['p_value'], method='fdr_bh')[1]

        plt.figure(figsize=(8, 6))

        # Plot with Matplotlib's bar (since sns.barplot expects a DataFrame)
        plt.bar(deviation_sorted.index.astype(str), deviation_sorted.values, color=colors, edgecolor='black',      
            linewidth=1.2, alpha=0.8)  # thickness of the bar edges

        # Add reference line
        plt.axhline(0, color='k', linestyle='--', linewidth=1)

        # --- Annotate significance stars ---
        ax = plt.gca()

        # Map adjusted p-values to cluster ids
        p_map = pvals.set_index('cluster_id')['p_adj']

        def stars(p):
            if p < 0.001: return '***'
            if p < 0.01:  return '**'
            if p < 0.05:  return '*'
            return ''

        # Vertical offset for labels
        ymin, ymax = ax.get_ylim()
        dy = 0.015 * (ymax - ymin)

        # Annotate bars
        for i, cid in enumerate(deviation_sorted.index):
            p = p_map.get(cid, np.nan)
            if pd.notna(p):
                s = stars(p)
                if s:
                    y = deviation_sorted.loc[cid]
                    ax.text(
                        i,
                        y + (dy if y >= 0 else -dy),
                        s,
                        ha='center',
                        va='bottom' if y >= 0 else 'top',
                        fontsize=10,
                        fontweight='bold',
                        color='black')

        # Labels and title
        plt.title("Cluster Deviation from Expected", fontsize=16, fontweight='bold')
        plt.ylabel("Deviation from Expected")
        plt.xlabel("Cluster ID")
        # plt.xticks(rotation=90)

        plt.tight_layout()
        path = os.path.join(output, 'deviations.png')  
        plt.savefig(path, dpi=300, bbox_inches='tight')
        path = os.path.join(output, 'figure_editable.pdf')  
        plt.savefig(path, format="pdf", bbox_inches="tight", dpi=300, transparent=True)
        plt.close()

     


    def cluster1234(self):

        df = self.df
        cluster_name = self.cluster_name 

        df = df[df[cluster_name].isin([1, 2, 3, 4])].copy() # clusters 1,2,3,4 only
        cluster_ids = sorted(df[cluster_name].unique())


        fig, axes = plt.subplots(
            4,4,
            figsize=(10, 12),
            constrained_layout=True)


        for ax in axes.flatten():
            ax.set_visible(False)

        row_labels = [
            "Speed",                     # 0
            "Minimum \nDistance",          # 1
            'Angle \nDeviation',           # 2
            'Initial \nInteraction \nType'        # 3
        ]


        for i, label in enumerate(row_labels):
            ax_label = axes[i, 0]  # first column of each row
            ax_label.set_ylabel(label, fontsize=10, rotation=0, labelpad=40, va='center')
        

        for column, cluster_id in enumerate(cluster_ids):
            cluster_df = df[df[cluster_name] == cluster_id]


            ## speed
            ax1 = axes[0, column]

            sns.lineplot(data=cluster_df, x='Normalized Frame', y='anchor_speed', label='Anchor', errorbar=('ci', 95), color='steelblue', ax=ax1)
            sns.lineplot(data=cluster_df, x='Normalized Frame', y='partner_speed', label='Partner', errorbar=('ci', 95), color='coral', ax=ax1)

            ax1.axvline(0, color="gray", ls="--", lw=0.5)
            ax1.set_ylim(0, 1.5)
            ax1.set_xticks([])
            # ax1.set_yticks([])
            ax1.set_visible(True)
            ax1.set_ylabel('')

            ax1.set_title(f"Cluster {cluster_id}", fontsize=14, fontweight='bold', pad=10)


            ## min_distance
            ax2 = axes[1, column]

            sns.lineplot(
            data=cluster_df,
            x='Normalized Frame',
            y='min_distance',
            errorbar=('ci', 95),
            color='rebeccapurple',
            ax=ax2)

            ax2.axvline(0, color='gray', linestyle='--', linewidth=0.5)
            ax2.set_ylim(0, 25)
            ax2.set_xticks([])
            ax2.set_visible(True)
            ax2.set_ylabel('')

            ## angle deviation

            cluster_df = cluster_df.sort_values(['interaction_id', 'Normalized Frame'])

            cluster_df['prev partner x_body'] = cluster_df.groupby('interaction_id')['partner x_body'].shift(1)
            cluster_df['prev partner y_body'] = cluster_df.groupby('interaction_id')['partner y_body'].shift(1)

            partner_position = np.array([cluster_df['partner x_body'], cluster_df['partner y_body']]).T
            partner_prev_position = np.array([cluster_df['prev partner x_body'], cluster_df['prev partner y_body']]).T
            anchor_position = np.array([cluster_df['anchor x_body'], cluster_df['anchor y_body']]).T 

            projection = anchor_position - partner_prev_position
            partner_direction  = partner_position - partner_prev_position

            def calculate_angle_between_two_angles(a, b):
                # rowwise dot and norms
                cos_theta = (a * b).sum(axis=1) / (np.linalg.norm(a, axis=1) * np.linalg.norm(b, axis=1))
                cos_theta = np.clip(cos_theta, -1.0, 1.0)  # avoid rounding errors
                theta_radians = np.arccos(cos_theta)
                return theta_radians

            def get_scalar_rejection(a, theta):
                rejection_magnitude = np.linalg.norm(a, axis=1) * np.sin(theta)
                return rejection_magnitude
            
            def get_scalar_projection(a, theta):
                projection_magnitude = np.linalg.norm(a, axis=1) * np.cos(theta)
                return projection_magnitude
            
            def distance(x, y):
                diff = x - y
                distance = np.linalg.norm(diff, axis=1)
                return distance
            
            # deviation angle from projected path 
            cluster_df['deviation_angle'] = calculate_angle_between_two_angles(partner_direction, projection)
            cluster_df['deviation_angle'] = np.degrees(cluster_df['deviation_angle']) # radians to degrees

            ax3 = axes[2, column]

            sns.lineplot(data=cluster_df, x='Normalized Frame', y='deviation_angle', legend='full', ci=95, ax=ax3, color='forestgreen')
            ax3.axvline(0, color='gray', linestyle='--', linewidth=0.5)

            ax3.set_xticks([])
            ax3.set_visible(True)
            ax3.set_ylabel('')

 
            ## initial interaction 

            interaction_colors = {
                "head-head": "darkred",
                "head-body": "orange",
                "head-tail": "yellow",
                "body-body": "black",
                "tail-tail": "black",
                "tail-body": "black"}
            

            interaction_merge_map = {
                "head-tail": "head-tail", "tail-head": "head-tail",
                "tail-body": "tail-body", "body-tail": "tail-body",
                "head-body": "head-body", "body-head": "head-body",
                "tail-tail": "tail-tail", "head-head": "head-head", "body-body": "body-body",
            }
            interaction_types = ["head-head", "head-body", "head-tail", "body-body", "tail-tail", "tail-body"]
            palette_list = [interaction_colors[t] for t in interaction_types]

            inter_ids = cluster_df["interaction_id"].unique()

            init_labels = []
            for inter_id in inter_ids:
                inter = cluster_df[cluster_df["interaction_id"] == inter_id].sort_values("Frame")

                # frames in contact (<1mm), merge symmetric labels
                close = inter[inter["min_distance"] < 1].copy()
                close["interaction_type_merged"] = close["interaction_type"].map(interaction_merge_map)

                # # counts per interaction (merged types)
                # counts = close["interaction_type_merged"].value_counts().to_dict()
                # row = {"interaction_id": inter_id}
                # for it in interaction_types:
                #     row[it] = counts.get(it, 0)
                # records.append(row)

                # initial & predominant labels, if any contact exists
                tm = close["interaction_type_merged"]
                if not tm.empty:
                    init_labels.append(tm.iloc[0])
                    # pred_labels.append(tm.value_counts().idxmax())

                # # total frames <1mm for this interaction
                # frames_close_list.append((inter_id, (inter["min_distance"] < 1).sum()))
            
            ax4 = axes[3, column]
            
            tmp_init = pd.DataFrame({
                    "contact_type": np.repeat(interaction_types, len(init_labels)),
                    "val": np.concatenate([(np.array(init_labels) == t).astype(int) for t in interaction_types])
                })

            sns.barplot(
                data=tmp_init, x="contact_type", y="val",
                errorbar=('ci', 95),
                order=interaction_types, palette=palette_list, ax=ax4, alpha=0.8, edgecolor='black', linewidth=1.2
            )

            ax4.set_ylim(0, 1)
            ax4.set_xticks([])
            ax4.set_xlabel('Contact Type')
            ax4.set_ylabel('')
            ax4.set_visible(True)

        for i, label in enumerate(row_labels):
            # Use the first column (axes[i, 0]) for each row label
            axes[i, 0].set_ylabel(
                label,
                fontsize=10,
                rotation=0,
                labelpad=40,
                va='center'
            )
        

    
        outdir = os.path.join(self.directory, "test")
        out_path = os.path.join(outdir, "summary_anchor_partner.png")
        plt.savefig(out_path, dpi=300, bbox_inches='tight')
        plt.close(fig)










            







        













if __name__ == "__main__":
    # Set your paths
    directory = "/Volumes/lab-windingm/home/users/cochral/LRS/AttractionRig/analysis/social-isolation/n10/umap-pipeline/youngser/test3_F18/test-new-pipeline/Yhat.idt.pca"
    interactions = "/Volumes/lab-windingm/home/users/cochral/LRS/AttractionRig/analysis/social-isolation/n10/umap-pipeline/youngser/test4_F29/cropped_interactions.csv"
    clusters = "/Volumes/lab-windingm/home/users/cochral/LRS/AttractionRig/analysis/social-isolation/n10/umap-pipeline/youngser/test3_F18/pca-data2-F18.csv"
    cluster_name = "Yhat.idt.pca"   # or whatever your cluster column is
    video_path = "/Volumes/lab-windingm/home/users/cochral/LRS/AttractionRig/analysis/social-isolation/n10/umap-pipeline/youngser/videos_original"

    # Create instance
    pipeline = ClusterPipeline(directory, interactions, clusters, cluster_name, video_path)

    # Run methods
    pipeline.loading_data()
    pipeline.anchor_partner()


    # pipeline.hierarchal_mean_trace_summary()
    # pipeline.barplots()
    pipeline.cluster1234()